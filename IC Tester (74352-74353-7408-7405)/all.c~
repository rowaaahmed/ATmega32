/*******************
This program was created by the
CodeWizardAVR V3.12 Advanced
Automatic Program Generator
© Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : 
Version : 
Date    : 12/31/2024
Author  : 
Company : 
Comments: 


Chip type               : ATmega32A
Program type            : Application
AVR Core Clock frequency: 11.059200 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 512
*******************/

#include <mega32a.h>

// Alphanumeric LCD functions
#include <alcd.h>
#include <stdio.h>
#include <delay.h>
// Declare your global variables here

unsigned char line[17];
unsigned char x;
signed char  j; 
unsigned char intr=0;     //Interrupt flag to indicate external interrupt occurrence
int counter=0;           // Counter for counting interrupt events 
unsigned char  flag=0;    //flags for the IC tests
unsigned char  flag2=0;
unsigned char  flag3=0;
unsigned char  flag4=0;
unsigned char actual_output;      //to store the output values of the ICs
unsigned char expected_output;    //to store the expected values from the ICs
// External Interrupt 0 service routine
interrupt [EXT_INT1] void ext_int1_isr(void)
{
// Place your code here
    unsigned int i , l,k;
    //delay to avoid debounce   

        intr=1;      //interrupt flag is raised
        counter++;    //counter increment  

}
void and_gate(){

    // Define pin mappings for the AND gate IC
    #define INPUT1_1 0
    #define INPUT2_1 1
    #define OUTPUT1 2
    #define INPUT1_2 3
    #define INPUT2_2 4
    #define OUTPUT2 5
    #define GND 6
    
    #define VCC 0
    #define INPUT1_3 1
    #define INPUT2_3 2
    #define OUTPUT3 3
    #define INPUT1_4 4
    #define INPUT2_4 5
    #define OUTPUT4 6
    

    unsigned char i = 0;
    flag2=0;     // Reset error flag

    // Configure pins as input or output for testing
    DDRA |= (1<<INPUT1_1) | (1<<INPUT2_1) | (1<<INPUT1_2) | (1<<INPUT2_2) | (1<<GND);
    DDRC |= (1<<INPUT1_3) | (1<<INPUT2_3) | (1<<INPUT1_4) | (1<<INPUT2_4) | (1<<VCC);
    
    DDRA &= ~(1<<OUTPUT1);
    DDRA &= ~(1<<OUTPUT2);
    DDRC &= ~(1<<OUTPUT3);
    DDRC &= ~(1<<OUTPUT4);
    PORTA |= (1<<OUTPUT1) | (1<<OUTPUT2) ; 
    PORTC |= (1<<OUTPUT4)| (1<<OUTPUT3);
    PORTA &=~(1<<GND);
    PORTC |= (1<<VCC); 
    
    // Test Case 1: Apply HIGH to all inputs and test outputs
    PORTA |= (1<<INPUT1_1) | (1<<INPUT2_1) | (1<<INPUT1_2) | (1<<INPUT2_2);
    PORTC |= (1<<INPUT1_3) | (1<<INPUT2_3) | (1<<INPUT1_4) | (1<<INPUT2_4); 
    if ((PINA.OUTPUT1) != 1){
        flag2=1;     // Output error
    }
    if ((PINA.OUTPUT2) != 1){
        flag2=1;    // Output error
    }
    if ((PINC.OUTPUT3) != 1){
        flag2=1;    // Output error
    }
    if ((PINC.OUTPUT4) != 1){
        flag2=1;    // Output error
    }
    
     // Test Case 2: Apply LOW to all inputs and test outputs
    PORTA &= ~(1<<INPUT1_1) ;
    PORTA &= ~(1<<INPUT2_1) ; 
    PORTA &= ~(1<<INPUT1_2) ;
    PORTA &= ~(1<<INPUT2_2) ;
    
    PORTC &= ~(1<<INPUT1_3) ;
    PORTC &= ~(1<<INPUT2_3) ;
    PORTC &= ~(1<<INPUT1_4) ;
    PORTC &= ~(1<<INPUT2_4) ;
    if ((PINA.OUTPUT1) != 0){
        flag2=1;  
    }
    if ((PINA.OUTPUT2) != 0){
        flag2=1;            
    }
    if ((PINC.OUTPUT3) != 0){
        flag2=1;
    }
    if ((PINC.OUTPUT4) != 0){
        flag2=1;
    } 
    
    // Test Case 3: Apply one LOW input and one HIGH input and test outputs
    PORTA |= (1<<INPUT1_1) | (1<<INPUT1_2);
    PORTA &= ~(1<<INPUT2_1);
    PORTA &= ~(1<<INPUT2_2);
     
    PORTC |= (1<<INPUT1_3) | (1<<INPUT1_4);
    PORTC &= ~(1<<INPUT2_3);
    PORTC &= ~(1<<INPUT2_4);
    
    if ((PINA.OUTPUT1) != 0){
        flag2=1;          // Output error
    }
    if ((PINA.OUTPUT2) != 0){
        flag2=1;          // Output error  
    }
    if ((PINC.OUTPUT3) != 0){
        flag2=1;         // Output error
    }
    if ((PINC.OUTPUT4) != 0){
        flag2=1;         // Output error
    }    
         
}
void not_gate(){

    // Define pin mappings for the NOT gate IC
    #define INPUT1 0
    #define OUTPUT1 1
    #define INPUT2 2
    #define OUTPUT2 3
    #define INPUT3 4
    #define OUTPUT3 5
    #define INPUT4 1
    #define OUTPUT4 2
    #define GND 6
    #define INPUT5 3
    #define OUTPUT5 4
    #define INPUT6 5
    #define OUTPUT6 6
    #define VCC 0

    
    flag3=0;       // Reset error flag
     
    // Configure pins as input or output for testing
    DDRA |= (1<<INPUT1) | (1<<INPUT2) | (1<<INPUT3) | (1<<GND);
    DDRC |= (1<<INPUT4) | (1<<INPUT5) | (1<<INPUT6) | (1<<VCC);

    DDRA &= ~(1<<OUTPUT1);
    DDRA &= ~(1<<OUTPUT2);
    DDRA &= ~(1<<OUTPUT3);
    DDRC &= ~(1<<OUTPUT4); 
    DDRC &= ~(1<<OUTPUT5);
    DDRC &= ~(1<<OUTPUT6);
    PORTA |= ( 1 << OUTPUT1) | ( 1 << OUTPUT2) | ( 1 << OUTPUT3);
    PORTC |= ( 1 << OUTPUT4) | ( 1 << OUTPUT5) | ( 1 << OUTPUT6);
    PORTA &= ~(1<<GND);
    PORTC |= (1<<VCC);
    
     // Test Case 1: Apply LOW to all inputs and test outputs 
    PORTA &= ~((1 << INPUT1) | (1 << INPUT2) | (1 << INPUT3));
    PORTC &= ~((1 << INPUT4) | (1 << INPUT5) | (1 << INPUT6));
    
    actual_output = 
        (((PINA >> 1) & 0x01) << 0) | 
        (((PINA >> 3) & 0x01) << 1) | 
        (((PINA >> 5) & 0x01) << 2) |
        (((PINC >> 2) & 0x01) << 3) | 
        (((PINC >> 4) & 0x01) << 4) | 
        (((PINC >> 6) & 0x01) << 5);           
    expected_output = 0x3F; 
    if (actual_output != expected_output) {   //to check if all outputs are HIGH
        flag3=1;     // Output error
    } 
    delay_ms(10);
    
     // Test Case 2: Apply HIGH to all inputs and test outputs
    PORTA |= ((1 << INPUT1) | (1 << INPUT2) | (1 << INPUT3));
    PORTC |= ((1 << INPUT4) | (1 << INPUT5) | (1 << INPUT6));        
    actual_output = 
        (((PINA >> 1) & 0x01) << 0) | 
        (((PINA >> 3) & 0x01) << 1) | 
        (((PINA >> 5) & 0x01) << 2) |
        (((PINC >> 2) & 0x01) << 3) | 
        (((PINC >> 4) & 0x01) << 4) | 
        (((PINC >> 6) & 0x01) << 5);               
    expected_output = 0x00; 
    if (actual_output != expected_output) {        //to check if all outputs are LOW
        flag3=1;      // Output error
    }           
}
void firstmux_ic(){
    // Define pin positions
    #define STROBE1 0
    #define INPUTB 1
    #define INPUT3 2
    #define INPUT2 3
    #define INPUT1 4
    #define INPUT0 5
    #define OUTPUTQ 6
    #define GND 7

    #define OUTPUTQ_2 7
    #define INPUT0_2 6
    #define INPUT1_2 5
    #define INPUT2_2 4
    #define INPUT3_2 3
    #define INPUTA 2
    #define STROBE2 1
    #define VCC 0  
    

    unsigned char inputs[14] = {STROBE1, INPUTB, INPUT3, INPUT2, INPUT1, INPUT0, GND, INPUT0_2, INPUT1_2, INPUT2_2, INPUT3_2, INPUTA, STROBE2, VCC};
    unsigned char outputs[2] = {OUTPUTQ, OUTPUTQ_2};

    unsigned char i,temp;
    unsigned char d;
    
    flag=0;       // Reset error flag
     
    DDRA=0;
    DDRC=0;
    
    // Configure inputs
    DDRA &= ~(1 << OUTPUTQ);
    DDRC &= ~(1 << OUTPUTQ_2);
    PORTA |= (1<<OUTPUTQ);
    PORTC |= (1<<OUTPUTQ_2);

    DDRA |= (1 << STROBE1) | (1 << INPUTB) | (1 << INPUT3) | (1 << INPUT2) | (1 << INPUT1) | (1 << INPUT0) | (1 << GND);
    DDRC |= (1 << INPUT0_2) | (1 << INPUT1_2) | (1 << INPUT2_2) | (1 << INPUT3_2) | (1 << INPUTA) | (1 << STROBE2) | (1 << VCC);
 
    PORTA = 0;
    PORTC = 0;
    PORTA &= ~(1<<GND);
    PORTC |= (1<<VCC);
    PORTA |= (1<<STROBE1);
    PORTC |= (1<<STROBE2);
    
    // Assign input values (use separate variables or arrays for runtime values)
    d = 0b1001;
    for (i=0; i<2; i++){
    
        //diffrent configurations depending on the value tested with 
        //start with first 4 inputs 
        if (d==9){
            PORTA |= (1<< INPUT3) | (1<< INPUT0) ;
            PORTA &= ~(1<< INPUT2);
            PORTA &= ~(1<< INPUT1) ;
        }
        else {
            PORTA &= ~(1<< INPUT3) ; 
            PORTA &= ~(1<< INPUT0) ;
            PORTA |= (1<< INPUT2) | (1<< INPUT1) ;
        }
        
        x=0;
        //Enable A and B pins of IC
        PORTA |= (1<<INPUTB) ;
        PORTC |= (1<< INPUTA);
        PORTA &= ~(1<<STROBE1);      //activate the inverted input
        delay_ms(2);
        temp = (PINA.OUTPUTQ);      //store the output result
        x = !temp;                  //store the complement of the output  
        PORTA |= (1<<STROBE1);       //deactivate the inverted input
        
        delay_ms(2);
        //Enable B and disable A   
        PORTA |= (1<<INPUTB) ;
        PORTC &= ~(1<< INPUTA);
        PORTA &= ~(1<<STROBE1);
        delay_ms(2);
        temp = (PINA.OUTPUTQ);
        x = (x << 1) | (!temp);         //append to the variable the complement of the output
        PORTA |= (1<<STROBE1);
        
        delay_ms(2);
        //Enable A and disable B     
        PORTA &= ~(1<<INPUTB) ;
        PORTC |= (1<< INPUTA);
        PORTA &= ~(1<<STROBE1);
        delay_ms(2);
        temp = (PINA.OUTPUTQ);
        x = (x << 1) | (!temp);        //append to the variable the complement of the output
        PORTA |= (1<<STROBE1);
        
        delay_ms(2);
        //Disable both    
        PORTA &= ~(1<<INPUTB) ;
        PORTC &= ~(1<< INPUTA); 
        PORTA &= ~(1<<STROBE1);
        delay_ms(2);
        temp = (PINA.OUTPUTQ);
        x = (x << 1) | (!temp);        //append to the variable the complement of the output
        PORTA |= (1<<STROBE1);
                 
        if (x != d){                  //Compare the values of the complement of the output with the input
            flag=1;     // Output error
            break;     //do not continue the loop
        }
        d=0b0110;
    } 
    
    d = 0b1001;
    for (i=0; i<2; i++){
        
        //Repeat the smae test for the second 4 inputs
        if (d==9){
            PORTC |= (1<< INPUT3_2) | (1<< INPUT0_2) ;
            PORTC &= ~(1<< INPUT2_2);
            PORTC &= ~(1<< INPUT1_2) ;
        }
        else {
            PORTC &= ~(1<< INPUT3_2) ;
            PORTC &= ~(1<< INPUT0_2) ;
            PORTC |= (1<< INPUT2_2) | (1<< INPUT1_2) ;
        }
        x=0; 
        
        PORTA |= (1<<INPUTB) ;
        PORTC |= (1<< INPUTA);
        PORTC &= ~(1<<STROBE2);
        delay_ms(2);
        temp = (PINC.OUTPUTQ_2);
        x = !temp;
        PORTC |= (1<<STROBE2);
        
        delay_ms(2);
        PORTA |= (1<<INPUTB) ;
        PORTC &= ~(1<< INPUTA);
        PORTC &= ~(1<<STROBE2);
        delay_ms(2);
        temp = (PINC.OUTPUTQ_2);
        x = (x << 1) | (!temp);
        PORTC |= (1<<STROBE2);
        
        delay_ms(2);
        PORTA &= ~(1<<INPUTB) ;
        PORTC |= (1<< INPUTA);
        PORTC &= ~(1<<STROBE2);
        delay_ms(2);
        temp = (PINC.OUTPUTQ_2);
        x = (x << 1) | (!temp);
        PORTC |= (1<<STROBE2);
        
        delay_ms(2);
        PORTA &= ~(1<<INPUTB) ;
        PORTC &= ~(1<< INPUTA);
        PORTC &= ~(1<<STROBE2);
        delay_ms(2);
        temp = (PINC.OUTPUTQ_2);
        x = (x << 1) | (!temp);
        PORTC |= (1<<STROBE2);
        
    
        if (x != d){
            flag=1;
            break;
        }
        d=0b0110;  
    }   
           
}
void secondmux_ic(){
    // Define pin positions
    #define STROBE1 0
    #define INPUTB 1
    #define INPUT3 2
    #define INPUT2 3
    #define INPUT1 4
    #define INPUT0 5
    #define OUTPUTQ 6
    #define GND 7

    #define OUTPUTQ_2 7
    #define INPUT0_2 6
    #define INPUT1_2 5
    #define INPUT2_2 4
    #define INPUT3_2 3
    #define INPUTA 2
    #define STROBE2 1
    #define VCC 0  
    

    unsigned char inputs[14] = {STROBE1, INPUTB, INPUT3, INPUT2, INPUT1, INPUT0, GND, INPUT0_2, INPUT1_2, INPUT2_2, INPUT3_2, INPUTA, STROBE2, VCC};
    unsigned char outputs[2] = {OUTPUTQ, OUTPUTQ_2};

    unsigned char i,temp;
    unsigned char d;
                     
    flag4=0;
    DDRA=0;
    DDRC=0;

    DDRA &= ~(1 << OUTPUTQ);
    DDRC &= ~(1 << OUTPUTQ_2);
    PORTA |= (1<<OUTPUTQ);
    PORTC |= (1<<OUTPUTQ_2);
    
    // Configure inputs

    DDRA |= (1 << STROBE1) | (1 << INPUTB) | (1 << INPUT3) | (1 << INPUT2) | (1 << INPUT1) | (1 << INPUT0) | (1 << GND);
    DDRC |= (1 << INPUT0_2) | (1 << INPUT1_2) | (1 << INPUT2_2) | (1 << INPUT3_2) | (1 << INPUTA) | (1 << STROBE2) | (1 << VCC);

    
    PORTA = 0;
    PORTC = 0;
    PORTA &= ~(1<<GND);
    PORTC |= (1<<VCC);
    PORTA |= (1<<STROBE1);
    PORTC |= (1<<STROBE2);
    
    
    //Change the direction of the output pin to be an output to the microcontroller 
    DDRA |= (1<<OUTPUTQ);
    PORTA |= (1<<OUTPUTQ);     //Write HIGH signal to it
    DDRA &= ~(1<<OUTPUTQ);     //Invert again
    PORTA |= (1<<OUTPUTQ);     //activate pull up
    if (PINA.OUTPUTQ != 1){    //check if the output is HIGH
        flag4=1;   // Output error
    }
    //Repeat the same test with a LOW signal
    DDRA |= (1<<OUTPUTQ);
    PORTA &= ~(1<<OUTPUTQ);
    DDRA &= ~(1<<OUTPUTQ);
    PORTA |= (1<<OUTPUTQ);
    if (PINA.OUTPUTQ != 0){
        flag4=1;
    }
    
    //Repeat the same test for the second output
    DDRC |= (1<<OUTPUTQ_2);
    PORTC |= (1<<OUTPUTQ_2);
    DDRC &= ~(1<<OUTPUTQ_2);
    PORTC |= (1<<OUTPUTQ_2);
    if (PINC.OUTPUTQ_2 != 1)
        flag4=1;
    DDRC |= (1<<OUTPUTQ_2);
    PORTC &= ~(1<<OUTPUTQ_2);
    DDRC &= ~(1<<OUTPUTQ_2);
    PORTC |= (1<<OUTPUTQ_2);
    if (PINC.OUTPUTQ != 0)
        flag4=1;           
}



void main(void)
{
// Declare your local variables here

// Input/Output Ports initialization
// Port A initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRA=(0<<DDA7) | (0<<DDA6) | (0<<DDA5) | (0<<DDA4) | (0<<DDA3) | (0<<DDA2) | (0<<DDA1) | (0<<DDA0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTA=(0<<PORTA7) | (0<<PORTA6) | (0<<PORTA5) | (0<<PORTA4) | (0<<PORTA3) | (0<<PORTA2) | (0<<PORTA1) | (0<<PORTA0);

// Port B initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRB=(0<<DDB7) | (0<<DDB6) | (0<<DDB5) | (0<<DDB4) | (0<<DDB3) | (1<<DDB2) | (1<<DDB1) | (0<<DDB0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);

// Port C initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRC=(0<<DDC7) | (0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTC=(0<<PORTC7) | (0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORTC0);

// Port D initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRD=(0<<DDD7) | (0<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTD=(0<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);

// External Interrupt(s) initialization
// INT0: On
// INT0 Mode: Falling Edge
// INT1: Off
// INT2: Off
GICR|=(1<<INT1) | (0<<INT0) | (0<<INT2);
MCUCR=(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);
MCUCSR=(0<<ISC2);
GIFR=(1<<INTF1) | (0<<INTF0) | (0<<INTF2);

// Alphanumeric LCD initialization
// Connections are specified in the
// Project|Configure|C Compiler|Libraries|Alphanumeric LCD menu:
// RS - PORTD Bit 0
// RD - PORTD Bit 1
// EN - PORTD Bit 2
// D4 - PORTD Bit 4
// D5 - PORTD Bit 5
// D6 - PORTD Bit 6
// D7 - PORTD Bit 7
// Characters/line: 16
lcd_init(16);

// Global enable interrupts
#asm("sei")

lcd_init(16);

while (1)
      {
      // Place your code here 
      lcd_init(16);        //LCD initialize 
      lcd_clear();        
      while(intr==0){    //while no interrupt signal recieved 
        lcd_gotoxy(0,0);
        sprintf(line, "ICs tested: %u", counter);       //print the number of tested ICs
        lcd_puts(line);
      }
      if (intr){
          lcd_clear();
          lcd_gotoxy(0,0);
          sprintf(line, "Testing the IC");     
          lcd_puts(line); 
          delay_ms(500);
          
          not_gate();                //call the NOT gate function
          if (flag3==0){             // check the flag
            lcd_clear();
            lcd_gotoxy(0,0);
            sprintf(line, "IC is 7405 ");      //if the flag is clear print the number of IC
            lcd_puts(line);
            delay_ms(2000);
          }
          
          and_gate();               //call the AND gate function
          if (flag2==0){
            lcd_clear();
            lcd_gotoxy(0,0);
            sprintf(line, "IC is 7408 ");     
            lcd_puts(line);
            delay_ms(2000);
          } 
          
          firstmux_ic();              //call the first mux function
          if (flag==0){               //to check the IC flag if clear
            secondmux_ic();           //call the second mux function as the are the same I/O test with an adddition to the second one
            if (flag4==0){
                lcd_clear();
                lcd_gotoxy(0,0);
                sprintf(line, "IC is 74353 ");     //if the test passed without errors print on the LCD the no. of second mux IC
                lcd_puts(line);
                delay_ms(2000); 
            }
            else{
                lcd_clear();
                lcd_gotoxy(0,0);
                sprintf(line, "IC is 74352 ");      //if not then the IC is the first one
                lcd_puts(line);
                delay_ms(2000);
            } 
          }
          
          if (flag==1 & flag2==1 & flag3==1 & flag4==1){          //if the IC is none of the ones listed
            lcd_clear();
            lcd_gotoxy(0,0);
            sprintf(line, "IC not found ");                      //unkown IC msg appears
            lcd_puts(line); 
            delay_ms(2000);
          }
          intr=0;                //clear the interrupt flag
      }
       

      }
}